// Generated by psc-bundle 0.11.6
var PS = {};
(function(exports) {
    "use strict";

  exports.log = function (s) {
    return function () {
      console.log(s);
      return {};
    };
  };
})(PS["Control.Monad.Eff.Console"] = PS["Control.Monad.Eff.Console"] || {});
(function(exports) {
    "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };

  exports.showNumberImpl = function (n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Data.Show"];     
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showNumber = new Show($foreign.showNumberImpl);
  var showInt = new Show($foreign.showIntImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showInt"] = showInt;
  exports["showNumber"] = showNumber;
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Control.Monad.Eff.Console"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Show = PS["Data.Show"];
  var Data_Unit = PS["Data.Unit"];
  exports["log"] = $foreign.log;
})(PS["Control.Monad.Eff.Console"] = PS["Control.Monad.Eff.Console"] || {});
(function(exports) {
    "use strict";

  exports.snoc = function (l) {
    return function (e) {
      var l1 = l.slice();
      l1.push(e);
      return l1;
    };
  };

  //------------------------------------------------------------------------------
  // Subarrays -------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.slice = function (s) {
    return function (e) {
      return function (l) {
        return l.slice(s, e);
      };
    };
  };
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
    "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];                         
  var append = function (dict) {
      return dict.append;
  };
  exports["append"] = append;
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Function = PS["Data.Function"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["mempty"] = mempty;
})(PS["Data.Monoid"] = PS["Data.Monoid"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Data.Foldable"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Endo = PS["Data.Monoid.Endo"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];
  var Prelude = PS["Prelude"];        
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var foldl = function (dict) {
      return dict.foldl;
  }; 
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  exports["Foldable"] = Foldable;
  exports["foldMap"] = foldMap;
  exports["foldMapDefaultR"] = foldMapDefaultR;
  exports["foldl"] = foldl;
  exports["foldr"] = foldr;
  exports["foldableArray"] = foldableArray;
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Data.Array"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Array_ST = PS["Data.Array.ST"];
  var Data_Array_ST_Iterator = PS["Data.Array.ST.Iterator"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Prelude = PS["Prelude"];
  exports["snoc"] = $foreign.snoc;
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
    "use strict";

  exports.unsafeParseFloat = parseFloat;
})(PS["Data.FFI"] = PS["Data.FFI"] || {});
(function(exports) {
  /* globals exports */
  "use strict";     

  exports.isNaN = isNaN;
})(PS["Global"] = PS["Global"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Global"];
  exports["isNaN"] = $foreign["isNaN"];
})(PS["Global"] = PS["Global"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Data.FFI"];
  var Data_Function = PS["Data.Function"];
  var Global = PS["Global"];
  var Prelude = PS["Prelude"];        
  var handleParseFloat = function (str) {
      var $0 = Global["isNaN"]($foreign.unsafeParseFloat(str));
      if ($0) {
          return 0.0;
      };
      return $foreign.unsafeParseFloat(str);
  };
  exports["handleParseFloat"] = handleParseFloat;
})(PS["Data.FFI"] = PS["Data.FFI"] || {});
(function(exports) {
    "use strict";

  exports.toStringAs = function (radix) {
    return function (i) {
      return i.toString(radix);
    };
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Data.Int"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Int_Bits = PS["Data.Int.Bits"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Show = PS["Data.Show"];
  var Global = PS["Global"];
  var $$Math = PS["Math"];
  var Prelude = PS["Prelude"];
  var decimal = 10;
  exports["decimal"] = decimal;
  exports["toStringAs"] = $foreign.toStringAs;
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semigroup_Foldable = PS["Data.Semigroup.Foldable"];
  var Data_Semigroup_Traversable = PS["Data.Semigroup.Traversable"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];        
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
})(PS["Data.List.Types"] = PS["Data.List.Types"] || {});
(function(exports) {
    "use strict";
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Prelude = PS["Prelude"];        

  /**
 * 
 *   GUARD PATTERN: |
 *   Makes sure for the guards to pass before executing the function
 */  
  var sum$prime = function (v) {
      if (v.length === 2 && (v[0] > 1 && v[1] > 2)) {
          return v[0] + v[1] | 0;
      };
      return 0;
  };

  /**
 * 
 *   ARRAY PATTERN: []
 *   Matches an array pattern and brings variables into scope
 */  
  var sum = function (v) {
      if (v.length === 2) {
          return v[0] + v[1] | 0;
      };
      return 0;
  };

  /**
 * 
 *   WILDCARD PATTERN: _
 *   A wildcard pattern matches any pattern and brings nothing into scope.
 *   If you want to match a pattern but not use it as a variable, this is what you would use.
 */  
  var someString = function (v) {
      return "Nothing to see here, move along!";
  };

  /**
 * 
 *   PATTERN GUARD PATTERN: 
 *   Makes sure a pattern guard exists and brings variables into scope
 */  
  var listSum = function (v) {
      var v1 = function (v2) {
          return 0;
      };
      if (v instanceof Data_List_Types.Cons && (v.value1 instanceof Data_List_Types.Cons && (v.value1.value1 instanceof Data_List_Types.Cons && v.value1.value1.value1 instanceof Data_List_Types.Nil))) {
          return (v.value0 + v.value1.value0 | 0) + v.value1.value1.value0 | 0;
      };
      return v1(true);
  };

  /**
 * 
 *   VARIABLE PATTERN: any variable
 *   Matches a pattern with a variable and brings that variable into scope
 */  
  var id = function (x) {
      return x;
  };

  /**
 * 
 *   NAMED PATTERN : @
 *   Matches a pattern to a variable and brings it into scope
 */  
  var getFullName$prime = function (v) {
      return v.firstName + (" " + v.lastName);
  };
  var getFullName = function (v) {
      return v.firstName + (" " + v.lastName);
  };
  exports["getFullName"] = getFullName;
  exports["getFullName'"] = getFullName$prime;
  exports["id"] = id;
  exports["listSum"] = listSum;
  exports["someString"] = someString;
  exports["sum"] = sum;
  exports["sum'"] = sum$prime;
})(PS["Data.PatternMatching"] = PS["Data.PatternMatching"] || {});
(function(exports) {
    "use strict";
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Int = PS["Data.Int"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Prelude = PS["Prelude"];        
  var whoIsRocky = {
      name: "Rocky Balboa", 
      age: 30, 
      weight: 200, 
      height: 62, 
      weightClass: "welterweight"
  };

  // type Person = { name :: String, age :: Int }
  var whoAmI = {
      name: "Adam", 
      age: 30
  };
  var showRocky = function (v) {
      return v.name + (" is in the " + (v.weightClass + " class."));
  };

  /**
 * 
 *   RECORD UPDATE
 */  
  var updateFighterWeightClass = function (class$prime) {
      return function (fighter) {
          return showRocky((function () {
              var $6 = {};
              for (var $7 in fighter) {
                  if ({}.hasOwnProperty.call(fighter, $7)) {
                      $6[$7] = fighter[$7];
                  };
              };
              $6.weightClass = class$prime;
              return $6;
          })());
      };
  };
  var showMe = function (v) {
      if (v.name === "Adam") {
          return v.name + (" is " + (Data_Int.toStringAs(Data_Int.decimal)(v.age) + " years old"));
      };
      return "Who are you?";
  };
  exports["showMe"] = showMe;
  exports["showRocky"] = showRocky;
  exports["updateFighterWeightClass"] = updateFighterWeightClass;
  exports["whoAmI"] = whoAmI;
  exports["whoIsRocky"] = whoIsRocky;
})(PS["Data.Records"] = PS["Data.Records"] || {});
(function(exports) {
    "use strict";

  exports.joinWith = function (s) {
    return function (xs) {
      return xs.join(s);
    };
  };
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var $foreign = PS["Data.String"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Show = PS["Data.Show"];
  var Data_String_Unsafe = PS["Data.String.Unsafe"];
  var Prelude = PS["Prelude"];
  exports["joinWith"] = $foreign.joinWith;
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
    "use strict";
  var Data_Array = PS["Data.Array"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function = PS["Data.Function"];
  var Data_Int = PS["Data.Int"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_String = PS["Data.String"];
  var Prelude = PS["Prelude"];        

  /**
 * 
 *   PRIMITIVE TYPES: Int, Number, String, Char, Boolean
 *   Number, String, Boolean work the same as in JavaScript.
 *   Int works differrently with operators in order for an Int to be returned.
 *   
 *   Examples:
 *   Int: 4
 *   Number: 4.0
 *   String: "Yo, Adrian!"
 *   Boolean: true
 */  

  /**
 *  
 *   TYPES: Arrays, Lists, Records
 *   Arrays work the same as in JavaScript but should have all the same type and are immutable.
 *   Lists are immutable linked lists.
 *   Records look and work the same as JavaScript objects and are also immutable.
 *   
 *   Examples:
 *   Array: [1, 2, 3, 4]
 *   List: (1 : 2 : 3 : 4 : Nil)
 *   Record: { name: "Rocky", wife: "Adrian", favoritePhrase: "Yo, Adrian!" }
 */  

  /**
 * 
 *   DYNAMIC TYPES: Tagged Union, Newtypes, Polymorphic, and Synonyms
 *   A tagged union allows you to create a data type in a more declarative way.
 *   Newtypes do the same but have one contructor and one argument.
 *   Polymorphic types just means that types can transform based on the arguments passed to a fuction.
 *   Synonyms allow you to define your records/functions/etc. in a type.
 *   
 *   Examples:
 *   Tagged Union: data Msg = Increment | Decrement
 *   Newtype: newtype Message = Message str
 *   Polymorphic: identity x = x
 *   Synonyms: type Data = { name :: String, wife :: String, favoritePhrase :: String  }
 */  

  // LETS CREATE SOME FUNCTIONS WITH THESE
  var ROCKY = (function () {
      function ROCKY() {

      };
      ROCKY.value = new ROCKY();
      return ROCKY;
  })();

  /**
 * 
 *   PRIMITIVE TYPES: Int, Number, String, Char, Boolean
 *   Number, String, Boolean work the same as in JavaScript.
 *   Int works differrently with operators in order for an Int to be returned.
 *   
 *   Examples:
 *   Int: 4
 *   Number: 4.0
 *   String: "Yo, Adrian!"
 *   Boolean: true
 */  

  /**
 *  
 *   TYPES: Arrays, Lists, Records
 *   Arrays work the same as in JavaScript but should have all the same type and are immutable.
 *   Lists are immutable linked lists.
 *   Records look and work the same as JavaScript objects and are also immutable.
 *   
 *   Examples:
 *   Array: [1, 2, 3, 4]
 *   List: (1 : 2 : 3 : 4 : Nil)
 *   Record: { name: "Rocky", wife: "Adrian", favoritePhrase: "Yo, Adrian!" }
 */  

  /**
 * 
 *   DYNAMIC TYPES: Tagged Union, Newtypes, Polymorphic, and Synonyms
 *   A tagged union allows you to create a data type in a more declarative way.
 *   Newtypes do the same but have one contructor and one argument.
 *   Polymorphic types just means that types can transform based on the arguments passed to a fuction.
 *   Synonyms allow you to define your records/functions/etc. in a type.
 *   
 *   Examples:
 *   Tagged Union: data Msg = Increment | Decrement
 *   Newtype: newtype Message = Message str
 *   Polymorphic: identity x = x
 *   Synonyms: type Data = { name :: String, wife :: String, favoritePhrase :: String  }
 */  

  // LETS CREATE SOME FUNCTIONS WITH THESE
  var ADRIAN = (function () {
      function ADRIAN() {

      };
      ADRIAN.value = new ADRIAN();
      return ADRIAN;
  })();

  // a type
  var greet = function (person) {
      if (person instanceof ROCKY) {
          return "Yo, Adrian";
      };
      if (person instanceof ADRIAN) {
          return "Rocky";
      };
      throw new Error("Failed pattern match at Data.Types line 55, column 3 - line 59, column 1: " + [ person.constructor.name ]);
  };
  var repeatGreets = function (arr) {
      return Data_Foldable.foldl(Data_Foldable.foldableArray)(function (acc) {
          return function (curr) {
              return Data_Array.snoc(acc)(greet(curr));
          };
      })([  ])(arr);
  };

  // snoc is the reverse of cons
  var printGreets = function (arr) {
      return Data_String.joinWith("! ")(repeatGreets(arr));
  };
  var fighterGreet = function (fighter) {
      return fighter.name + (" is " + (Data_Int.toStringAs(Data_Int.decimal)(fighter.age) + " years old"));
  };
  exports["ROCKY"] = ROCKY;
  exports["ADRIAN"] = ADRIAN;
  exports["fighterGreet"] = fighterGreet;
  exports["greet"] = greet;
  exports["printGreets"] = printGreets;
  exports["repeatGreets"] = repeatGreets;
})(PS["Data.Types"] = PS["Data.Types"] || {});
(function(exports) {
  // Generated by purs version 0.11.6
  "use strict";
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Console = PS["Control.Monad.Eff.Console"];
  var Data_FFI = PS["Data.FFI"];
  var Data_Function = PS["Data.Function"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_PatternMatching = PS["Data.PatternMatching"];
  var Data_Records = PS["Data.Records"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_Types = PS["Data.Types"];
  var Prelude = PS["Prelude"];        
  var main = function __do() {
      Control_Monad_Eff_Console.log("Hello, sailor")();
      Control_Monad_Eff_Console.log("Print Adrian using")();
      Control_Monad_Eff_Console.log(Data_Types.greet(Data_Types.ADRIAN.value) + "!")();
      Control_Monad_Eff_Console.log("Print a bunch of yo adrians")();
      Control_Monad_Eff_Console.log(Data_Types.printGreets([ Data_Types.ROCKY.value, Data_Types.ADRIAN.value, Data_Types.ROCKY.value, Data_Types.ADRIAN.value, Data_Types.ROCKY.value, Data_Types.ADRIAN.value ]))();
      Control_Monad_Eff_Console.log("Print Rocky's name")();
      Control_Monad_Eff_Console.log(Data_Types.fighterGreet({
          name: "Rocky Balboa", 
          age: 50
      }) + ".")();
      Control_Monad_Eff_Console.log("Let's do some pattern matching")();
      Control_Monad_Eff_Console.log("Wildcard Pattern")();
      Control_Monad_Eff_Console.log(Data_PatternMatching.someString("Something"))();
      Control_Monad_Eff_Console.log("Variable Pattern")();
      Control_Monad_Eff_Console.log(Data_PatternMatching.id("ID"))();
      Control_Monad_Eff_Console.log("Array Pattern")();
      Control_Monad_Eff_Console.log(Data_Show.show(Data_Show.showInt)(Data_PatternMatching.sum([ 10, 10 ])))();
      Control_Monad_Eff_Console.log("Record Pattern")();
      Control_Monad_Eff_Console.log(Data_PatternMatching.getFullName({
          firstName: "Adam", 
          lastName: "Recvlohe", 
          age: 30
      }))();
      Control_Monad_Eff_Console.log("Named Pattern")();
      Control_Monad_Eff_Console.log(Data_PatternMatching["getFullName'"]({
          firstName: "Adam", 
          lastName: "Recvlohe", 
          age: 30
      }))();
      Control_Monad_Eff_Console.log("Guard Pattern")();
      Control_Monad_Eff_Console.log(Data_Show.show(Data_Show.showInt)(Data_PatternMatching["sum'"]([ 0, 1 ])))();
      Control_Monad_Eff_Console.log("Pattern Guard Pattern")();
      Control_Monad_Eff_Console.log(Data_Show.show(Data_Show.showInt)(Data_PatternMatching.listSum(new Data_List_Types.Cons(1, new Data_List_Types.Cons(2, new Data_List_Types.Cons(3, Data_List_Types.Nil.value))))))();
      Control_Monad_Eff_Console.log("Foreign Function Interface")();
      Control_Monad_Eff_Console.log(Data_Show.show(Data_Show.showNumber)(Data_FFI.handleParseFloat("45")))();
      Control_Monad_Eff_Console.log(Data_Show.show(Data_Show.showNumber)(Data_FFI.handleParseFloat("asdfasdf.45")))();
      Control_Monad_Eff_Console.log(Data_Records.showMe(Data_Records.whoAmI))();
      Control_Monad_Eff_Console.log(Data_Records.showRocky(Data_Records.whoIsRocky))();
      return Control_Monad_Eff_Console.log(Data_Records.updateFighterWeightClass("heavyweight")(Data_Records.whoIsRocky))();
  };
  exports["main"] = main;
})(PS["Main"] = PS["Main"] || {});
PS["Main"].main();
